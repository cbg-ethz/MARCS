bdepar=bdepar)
}
scorepar$n <- n # to avoid to scoring over background nodes
# scoresagainstclusters[,k] <- BiDAG::scoreagainstDAGscoreagainstDAG(scorepar,clustercenters[[k]])
# if (score_type=="bdecat"){
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))))
# }else{
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]])
# }
if (score_type=="bdecat"){
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))), datatoscore = data_classify)
}else{
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], datatoscore = data_classify)
}
scorepar$n <- n+n_bg # recet after scoring
return(scoresagainstclusters[,k])
# }, mc.cores = k_clust)
})
for (kk in 1:k_clust){
scoresagainstclusters[,kk] <- parRes[[kk]]
}
# assign cluster
newallrelativeprobabsnotau <- graphClust:::allrelativeprobs(scoresagainstclusters)
newallrelativeprobabs <- graphClust:::relativeprobswithtau(newallrelativeprobabsnotau,tauvec)
newclustermembership<-graphClust:::reassignsamples(newallrelativeprobabs)
return(list("clustermembership"=newclustermembership,"allrelativeprobabs"=newallrelativeprobabs, "shared_vars"=shared_vars, "classified_data"=myData))
}
reclass <- get_classification(cluster_results, validata)
reclass
reclass <- get_classification(cluster_results = cluster_results, data_classify = validata)
reclass
library(clustNet)
library(parallel)
library(xlsx)
rm(list=ls())
cluster_results <- readRDS("../results/euler_memberships_8k_9clusters.rds")
validata <- read.csv("./aa1.csv")
rownames(validata) <- validata$X
validata$X <- NULL
validata <- as.data.frame(validata)
dim(validata)
# define the function
get_classification <- function(cluster_results, data_classify){
myData <- cluster_results$data
k_clust <- length(cluster_results$DAGs)
if(is.vector(data_classify)){
data_classify <- t(as.data.frame(data_classify)) # when this is a single col entry
}else{
data_classify <- as.data.frame(data_classify)
}
# input is clustercenters
clustercenters <- cluster_results$DAGs
newallrelativeprobabs <- cluster_results$probs
## detect and adjust for missing data
# Create two example matrices
matrix_one <- myData
# Create two example matrices
matrix_two <- data_classify
# Find shared variables
shared_vars <- intersect(colnames(matrix_one), colnames(matrix_two))
# cat("Shared variables:", shared_vars, "\n")
# Find missing variables in matrix_one
missing_vars_one <- setdiff(colnames(matrix_one), colnames(matrix_two))
if(length(missing_vars_one)> 0){
cat("Missing variables in cluster data:", missing_vars_one, "\n")
}
# Find missing variables in matrix_two
missing_vars_two <- setdiff(colnames(matrix_two), colnames(matrix_one))
if(length(missing_vars_two)> 0){
cat("Missing variables in classification data:", missing_vars_two, "\n")
}
# Get column indices of shared variables in matrix_one
if (length(shared_vars) > 0) {
shared_columns_indices_one <- match(shared_vars, colnames(matrix_one))
shared_columns_indices_two <- match(shared_vars, colnames(matrix_two))
# adapt data to shared vars
myData <- matrix_one[,shared_columns_indices_one]
data_classify <- matrix_two[,shared_columns_indices_two]
# adapt DAGs to shared vars
for (ii in 1:k_clust){
clustercenters[[ii]] <- clustercenters[[ii]][shared_columns_indices_one,shared_columns_indices_one]
}
} else {
cat("No shared variables\n")
}
## classification
data_classify <- unname(data_classify)
# number of background variables
n_bg <- 2
# total number of variables
ss <- dim(myData)[1]
nn <- dim(myData)[2]
ss2 <- NROW(data_classify)
#number of variables (without covariates)
n<-nn-n_bg
scoresagainstclusters<-matrix(ncol=k_clust,nrow=ss2)
bdepar <- list(chi = 0.5, edgepf = 8)
if (!all(myData < 2)){
# cetegorical version
score_type <- "bdecat"
}else{
# binary version
score_type <- "bde"
}
allrelativeprobabs<-newallrelativeprobabs
coltots<-colSums(allrelativeprobabs) + bdepar$chi # add prior to clustersizes
tauvec<-coltots/sum(coltots)
parRes <- parallel::mclapply(1:k_clust, function(k) {
if (n_bg>0){
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData),
weightvector=allrelativeprobabs[,k],
bdepar=bdepar, bgnodes=(n+1):(n+n_bg))
}else{
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData), edgepmat = edgepmat,
weightvector=allrelativeprobabs[,k],
bdepar=bdepar)
}
scorepar$n <- n # to avoid to scoring over background nodes
# scoresagainstclusters[,k] <- BiDAG::scoreagainstDAGscoreagainstDAG(scorepar,clustercenters[[k]])
# if (score_type=="bdecat"){
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))))
# }else{
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]])
# }
if (score_type=="bdecat"){
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))), datatoscore = data_classify)
}else{
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], datatoscore = data_classify)
}
scorepar$n <- n+n_bg # recet after scoring
return(scoresagainstclusters[,k])
# }, mc.cores = k_clust)
})
for (kk in 1:k_clust){
scoresagainstclusters[,kk] <- parRes[[kk]]
}
# assign cluster
newallrelativeprobabsnotau <- graphClust:::allrelativeprobs(scoresagainstclusters)
newallrelativeprobabs <- graphClust:::relativeprobswithtau(newallrelativeprobabsnotau,tauvec)
newclustermembership<-graphClust:::reassignsamples(newallrelativeprobabs)
print(newallrelativeprobabs)
return(list("clustermembership"=newclustermembership,"allrelativeprobabs"=newallrelativeprobabs, "shared_vars"=shared_vars, "classified_data"=myData))
}
reclass <- get_classification(cluster_results = cluster_results, data_classify = validata)
data_classify <- validata
myData <- cluster_results$data
k_clust <- length(cluster_results$DAGs)
if(is.vector(data_classify)){
data_classify <- t(as.data.frame(data_classify)) # when this is a single col entry
}else{
data_classify <- as.data.frame(data_classify)
}
# input is clustercenters
clustercenters <- cluster_results$DAGs
newallrelativeprobabs <- cluster_results$probs
newallrelativeprobabs
clustercenters
# Create two example matrices
matrix_one <- myData
# Create two example matrices
matrix_two <- data_classify
matrix_two
# Find shared variables
shared_vars <- intersect(colnames(matrix_one), colnames(matrix_two))
# Find missing variables in matrix_one
missing_vars_one <- setdiff(colnames(matrix_one), colnames(matrix_two))
if(length(missing_vars_one)> 0){
cat("Missing variables in cluster data:", missing_vars_one, "\n")
}
# Find missing variables in matrix_two
missing_vars_two <- setdiff(colnames(matrix_two), colnames(matrix_one))
if(length(missing_vars_two)> 0){
cat("Missing variables in classification data:", missing_vars_two, "\n")
}
missing_vars_two
missing_vars_one
# Get column indices of shared variables in matrix_one
if (length(shared_vars) > 0) {
shared_columns_indices_one <- match(shared_vars, colnames(matrix_one))
shared_columns_indices_two <- match(shared_vars, colnames(matrix_two))
# adapt data to shared vars
myData <- matrix_one[,shared_columns_indices_one]
data_classify <- matrix_two[,shared_columns_indices_two]
# adapt DAGs to shared vars
for (ii in 1:k_clust){
clustercenters[[ii]] <- clustercenters[[ii]][shared_columns_indices_one,shared_columns_indices_one]
}
} else {
cat("No shared variables\n")
}
data_classify
data_classify <- unname(data_classify)
data_classify
# number of background variables
n_bg <- 2
# total number of variables
ss <- dim(myData)[1]
nn <- dim(myData)[2]
ss2 <- NROW(data_classify)
#number of variables (without covariates)
n<-nn-n_bg
scoresagainstclusters<-matrix(ncol=k_clust,nrow=ss2)
scoresagainstclusters
ss2
nn
ss
#number of variables (without covariates)
n<-nn-n_bg
k_clust
ss2
scoresagainstclusters<-matrix(ncol=k_clust,nrow=ss2)
bdepar <- list(chi = 0.5, edgepf = 8)
if (!all(myData < 2)){
# cetegorical version
score_type <- "bdecat"
}else{
# binary version
score_type <- "bde"
}
allrelativeprobabs<-newallrelativeprobabs
coltots<-colSums(allrelativeprobabs) + bdepar$chi # add prior to clustersizes
tauvec<-coltots/sum(coltots)
parRes <- parallel::mclapply(1:k_clust, function(k) {
if (n_bg>0){
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData),
weightvector=allrelativeprobabs[,k],
bdepar=bdepar, bgnodes=(n+1):(n+n_bg))
}else{
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData), edgepmat = edgepmat,
weightvector=allrelativeprobabs[,k],
bdepar=bdepar)
}
scorepar$n <- n # to avoid to scoring over background nodes
# scoresagainstclusters[,k] <- BiDAG::scoreagainstDAGscoreagainstDAG(scorepar,clustercenters[[k]])
# if (score_type=="bdecat"){
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))))
# }else{
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]])
# }
if (score_type=="bdecat"){
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))), datatoscore = data_classify)
}else{
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], datatoscore = data_classify)
}
scorepar$n <- n+n_bg # recet after scoring
return(scoresagainstclusters[,k])
# }, mc.cores = k_clust)
})
parRes
library(clustNet)
library(parallel)
library(xlsx)
rm(list=ls())
cluster_results <- readRDS("../results/euler_memberships_8k_9clusters.rds")
validata <- read.table("../data/mda_binary-mutationCovariate-matrix.txt")[,-58]
mutation_covariate_data <- readRDS("../validation//aml_data.rds")
validata$UPI <- mutation_covariate_data$UPI
riskstrat <- readRDS("../validation//risk_scores.rds")
library(clustNet)
library(parallel)
library(xlsx)
rm(list=ls())
cluster_results <- readRDS("../results/euler_memberships_8k_9clusters.rds")
validata <- read.table("../data/mda_binary-mutationCovariate-matrix.txt")[,-58]
mutation_covariate_data <- readRDS("../validation//aml_data.rds")
validata$UPI <- mutation_covariate_data$UPI
riskstrat <- readRDS("../validation//risk_scores.rds")
# ids <- mutation_covariate_data$UPI[mutation_covariate_data$Dx %in% c("AML","MDS")]
# validata <- validata[validata$UPI %in% ids,]
# totdata <- merge(totdata, riskstrat[,c(1,85)], by="UPI")
# totdata <- totdata[totdata$UPI %in% ids,]
colnames(validata)[colnames(validata)=="CG_8"] <- "X.8"
colnames(validata)[colnames(validata)=="CG_5"] <- "X.5"
colnames(validata)[colnames(validata)=="CG_7"] <- "X.7"
colnames(validata)[colnames(validata)=="CG_inv16"] <- "inv.16."
colnames(validata)[colnames(validata)=="CG_8_21"] <- "t.8.21."
colnames(validata)[colnames(validata)=="BM_Blast"] <- "BM_BLASTS"
colnames(validata)[colnames(validata)=="PB_HGB"] <- "HB"
colnames(validata)[colnames(validata)=="PB_PLT"] <- "PLT"
colnames(validata)[colnames(validata)=="PB_WBC"] <- "WBC"
colnames(validata)[colnames(validata)=="age"] <- "AGE"
colnames(validata)[colnames(validata)=="sex"] <- "SEX"
dim(validata)
validata
library(clustNet)
library(parallel)
library(xlsx)
rm(list=ls())
cluster_results <- readRDS("../results/euler_memberships_8k_9clusters.rds")
validata <- read.csv("./aa1.csv")
rownames(validata) <- validata$X
validata$X <- NULL
validata <- as.data.frame(validata)
dim(validata)
# define the function
get_classification <- function(cluster_results, data_classify){
myData <- cluster_results$data
k_clust <- length(cluster_results$DAGs)
if(is.vector(data_classify)){
data_classify <- t(as.data.frame(data_classify)) # when this is a single col entry
}else{
data_classify <- as.data.frame(data_classify)
}
# input is clustercenters
clustercenters <- cluster_results$DAGs
newallrelativeprobabs <- cluster_results$probs
## detect and adjust for missing data
# Create two example matrices
matrix_one <- myData
# Create two example matrices
matrix_two <- data_classify
# Find shared variables
shared_vars <- intersect(colnames(matrix_one), colnames(matrix_two))
# cat("Shared variables:", shared_vars, "\n")
# Find missing variables in matrix_one
missing_vars_one <- setdiff(colnames(matrix_one), colnames(matrix_two))
if(length(missing_vars_one)> 0){
cat("Missing variables in cluster data:", missing_vars_one, "\n")
}
# Find missing variables in matrix_two
missing_vars_two <- setdiff(colnames(matrix_two), colnames(matrix_one))
if(length(missing_vars_two)> 0){
cat("Missing variables in classification data:", missing_vars_two, "\n")
}
# Get column indices of shared variables in matrix_one
if (length(shared_vars) > 0) {
shared_columns_indices_one <- match(shared_vars, colnames(matrix_one))
shared_columns_indices_two <- match(shared_vars, colnames(matrix_two))
# adapt data to shared vars
myData <- matrix_one[,shared_columns_indices_one]
data_classify <- matrix_two[,shared_columns_indices_two]
# adapt DAGs to shared vars
for (ii in 1:k_clust){
clustercenters[[ii]] <- clustercenters[[ii]][shared_columns_indices_one,shared_columns_indices_one]
}
} else {
cat("No shared variables\n")
}
## classification
data_classify <- unname(data_classify)
# number of background variables
n_bg <- 2
# total number of variables
ss <- dim(myData)[1]
nn <- dim(myData)[2]
ss2 <- NROW(data_classify)
#number of variables (without covariates)
n<-nn-n_bg
scoresagainstclusters<-matrix(ncol=k_clust,nrow=ss2)
bdepar <- list(chi = 0.5, edgepf = 8)
if (!all(myData < 2)){
# cetegorical version
score_type <- "bdecat"
}else{
# binary version
score_type <- "bde"
}
allrelativeprobabs<-newallrelativeprobabs
coltots<-colSums(allrelativeprobabs) + bdepar$chi # add prior to clustersizes
tauvec<-coltots/sum(coltots)
parRes <- parallel::mclapply(1:k_clust, function(k) {
if (n_bg>0){
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData),
weightvector=allrelativeprobabs[,k],
bdepar=bdepar, bgnodes=(n+1):(n+n_bg))
}else{
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData), edgepmat = edgepmat,
weightvector=allrelativeprobabs[,k],
bdepar=bdepar)
}
scorepar$n <- n # to avoid to scoring over background nodes
# scoresagainstclusters[,k] <- BiDAG::scoreagainstDAGscoreagainstDAG(scorepar,clustercenters[[k]])
# if (score_type=="bdecat"){
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))))
# }else{
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]])
# }
if (score_type=="bdecat"){
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))), datatoscore = data_classify)
}else{
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], datatoscore = data_classify)
}
scorepar$n <- n+n_bg # recet after scoring
return(scoresagainstclusters[,k])
# }, mc.cores = k_clust)
})
for (kk in 1:k_clust){
scoresagainstclusters[,kk] <- parRes[[kk]]
}
# assign cluster
newallrelativeprobabsnotau <- graphClust:::allrelativeprobs(scoresagainstclusters)
newallrelativeprobabs <- graphClust:::relativeprobswithtau(newallrelativeprobabsnotau,tauvec)
newclustermembership<-graphClust:::reassignsamples(newallrelativeprobabs)
print(newallrelativeprobabs)
return(list("clustermembership"=newclustermembership,"allrelativeprobabs"=newallrelativeprobabs, "shared_vars"=shared_vars, "classified_data"=myData))
}
reclass <- get_classification(cluster_results = cluster_results, data_classify = validata)
reclass
library(clustNet)
library(parallel)
library(xlsx)
rm(list=ls())
cluster_results <- readRDS("../results/euler_memberships_8k_9clusters.rds")
validata <- read.csv("./aa1.csv")
rownames(validata) <- validata$X
validata$X <- NULL
validata <- as.data.frame(validata)
dim(validata)
# define the function
get_classification <- function(cluster_results, data_classify){
myData <- cluster_results$data
k_clust <- length(cluster_results$DAGs)
if(is.vector(data_classify)){
data_classify <- t(as.data.frame(data_classify)) # when this is a single col entry
}else{
data_classify <- as.data.frame(data_classify)
}
# input is clustercenters
clustercenters <- cluster_results$DAGs
newallrelativeprobabs <- cluster_results$probs
## detect and adjust for missing data
# Create two example matrices
matrix_one <- myData
# Create two example matrices
matrix_two <- data_classify
# Find shared variables
shared_vars <- intersect(colnames(matrix_one), colnames(matrix_two))
# cat("Shared variables:", shared_vars, "\n")
# Find missing variables in matrix_one
missing_vars_one <- setdiff(colnames(matrix_one), colnames(matrix_two))
if(length(missing_vars_one)> 0){
cat("Missing variables in cluster data:", missing_vars_one, "\n")
}
# Find missing variables in matrix_two
missing_vars_two <- setdiff(colnames(matrix_two), colnames(matrix_one))
if(length(missing_vars_two)> 0){
cat("Missing variables in classification data:", missing_vars_two, "\n")
}
# Get column indices of shared variables in matrix_one
if (length(shared_vars) > 0) {
shared_columns_indices_one <- match(shared_vars, colnames(matrix_one))
shared_columns_indices_two <- match(shared_vars, colnames(matrix_two))
# adapt data to shared vars
myData <- matrix_one[,shared_columns_indices_one]
data_classify <- matrix_two[,shared_columns_indices_two]
# adapt DAGs to shared vars
for (ii in 1:k_clust){
clustercenters[[ii]] <- clustercenters[[ii]][shared_columns_indices_one,shared_columns_indices_one]
}
} else {
cat("No shared variables\n")
}
## classification
data_classify <- unname(data_classify)
# number of background variables
n_bg <- 2
# total number of variables
ss <- dim(myData)[1]
nn <- dim(myData)[2]
ss2 <- NROW(data_classify)
#number of variables (without covariates)
n<-nn-n_bg
scoresagainstclusters<-matrix(ncol=k_clust,nrow=ss2)
bdepar <- list(chi = 0.5, edgepf = 8)
if (!all(myData < 2)){
# cetegorical version
score_type <- "bdecat"
}else{
# binary version
score_type <- "bde"
}
allrelativeprobabs<-newallrelativeprobabs
coltots<-colSums(allrelativeprobabs) + bdepar$chi # add prior to clustersizes
tauvec<-coltots/sum(coltots)
parRes <- parallel::mclapply(1:k_clust, function(k) {
if (n_bg>0){
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData),
weightvector=allrelativeprobabs[,k],
bdepar=bdepar, bgnodes=(n+1):(n+n_bg))
}else{
scorepar <- BiDAG::scoreparameters(score_type,as.data.frame(myData), edgepmat = edgepmat,
weightvector=allrelativeprobabs[,k],
bdepar=bdepar)
}
scorepar$n <- n # to avoid to scoring over background nodes
# scoresagainstclusters[,k] <- BiDAG::scoreagainstDAGscoreagainstDAG(scorepar,clustercenters[[k]])
# if (score_type=="bdecat"){
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))))
# }else{
#   scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]])
# }
if (score_type=="bdecat"){
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], bdecatCvec = apply(myData, 2, function(x) length(unique(x))), datatoscore = data_classify)
}else{
scoresagainstclusters[,k] <- BiDAG::scoreagainstDAG(scorepar,clustercenters[[k]], datatoscore = data_classify)
}
scorepar$n <- n+n_bg # recet after scoring
return(scoresagainstclusters[,k])
# }, mc.cores = k_clust)
})
for (kk in 1:k_clust){
scoresagainstclusters[,kk] <- parRes[[kk]]
}
# assign cluster
newallrelativeprobabsnotau <- graphClust:::allrelativeprobs(scoresagainstclusters)
newallrelativeprobabs <- graphClust:::relativeprobswithtau(newallrelativeprobabsnotau,tauvec)
newclustermembership<-graphClust:::reassignsamples(newallrelativeprobabs)
print(newallrelativeprobabs)
return(list("clustermembership"=newclustermembership,"allrelativeprobabs"=newallrelativeprobabs, "shared_vars"=shared_vars, "classified_data"=myData))
}
reclass <- get_classification(cluster_results = cluster_results, data_classify = validata)
reclass
